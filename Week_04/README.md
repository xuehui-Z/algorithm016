# 学习笔记 第四周
### 知识总结
- **深度优先搜索(DFS, depth first search)**  
  深度优先搜索是一条路走到底的一种搜索方式，它能最快到达终点。  
  *参考题目 最小基因变化： https://leetcode-cn.com/problems/minimum-genetic-mutation/*
- **广度优先搜索(BFS, breadth first search)**  
  广度优先搜索是探索每种可能性的方式，它对于解决最短和最少问题特别有效。  
  *对于单词接龙这个问题，广度优先和深度优先的对比就比较明显了。*  
  *单词接龙 ： https://leetcode-cn.com/problems/word-ladder/*  
  *单词接龙Ⅱ： https://leetcode-cn.com/problems/word-ladder-ii/*
- **贪心算法**  
  贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有
利）的选择，从而希望导致结果是全局最好或最优的算法。使用贪心算法的前提是能保证每一步的最优解能导致全局最优解。否则就老老实实使用动态规划去吧。
相对于动态规划，贪心算法更简便。
- **二分算法**  
  - 二分查找的前提是  
  目标对象具有单调性(单调递增或者单调递减)；  
  存在左右边界；
  能够通过索引访问  
  - 代码模板
	```python
	left, right = 0, len(array) - 1 
	while left <= right: 
		mid = (left + right) / 2 
		if array[mid] == target: 
			# find the target!! 
			break or return result 
		elif array[mid] < target: 
			left = mid + 1 
		else: 
			right = mid - 1
	```
  - 题目练习：寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方  
    - 思路：找到中间值和左边界值，右边界值进行对比确定出新的左右边界，当左边界值<中间值,说明左边是没有无序的，无序的在右边，反之在左边，反复对比之后，当中间值等于边界值的时候，此时中间值就是无序的地方。
  
### 个人总结
DFS可以理解成是一个栈，栈中存在的是从根节点到孩子节点的一条完整路径，当一条路走到尽头的时候，出栈，换下一个子节点；BFS可以理解成是个队列，队列中存在的是一个节点的所有孩子节点，当这些节点遍历完成，把它们的所有孩子节点放入队列。  
贪心算法很容易理解，也很容易实现，但是使用它有一定的前提条件，即局部最优解能组合成全局最优解。只要能证明这一点就可以使用贪心。  
二分法也有一定的前提条件，即要具有单调性，能通过左右边界值和中间值确认出目标值的范围，这样每次就节省了一般的无效查找。