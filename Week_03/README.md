# 学习笔记 第3周
### 知识回顾-数据结构的总结
前两周主要学习了数据结构，下面先做一个简单的总结。
- **数组**  
  - 一维数组
  - 二维数组  
  **数组采用下标值来查询数据，查询和修改的时间复杂度为O(1),插入和删除的时间复杂度最坏为O(n)。**
- **链表**
  - 单向链表：每个节点有一个next指针指向下一个元素
  - 双向项链：每个节点有next和previous指针，分别指向下一个和前一个元素  
  **链表的查询和修改的时间复杂度为O(n),插入和删除的时间复杂度为O(1)。**
- **跳表**  
  将链表这种一维线性结构，升级成二维结构，优化了查询效率，同时降低了插入和删除的效率，是一种折中的办法。
- **队列**
  - **一般队列**类似于单向管道，是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。
  - **双端队列**则类似于双向管道，元素可以在队列头和队列尾进行插入删除操作。
  - **优先队列**中的元素具有优先级，具有最高优先级的元素最先被消费。一般采用堆的数据结构来实现。
- **栈**
  只开放一个端口，元素的追加和消费都在这一个端口实现，具有先进后出的特点。
- **哈希表**
  采用哈希算法，一般以Key-Value的形式存储数据，根据Key的哈希值计算在数组中的下标值。
- **树**
  - 二叉树  
  二叉树的形态多种多样，主要有搜索二叉树和平衡二叉树，搜索二叉树是按照一定顺序存储根节点和左右节点的，比如要求：左节点<=根节点<=右节点，这样按照一定顺序遍历树，就可以得到一个有序的数组。平衡二叉树是左右子树之间的高度差不超过1，这就保证了左右子节点基本是平衡的，搜索的效率能保证在O(log(n))，不会出现因为节点都在左边或者都在右边导致最坏的O(n)时间复杂度。
  - N叉树  
  同样分为平衡树和多路搜索树，主要的实现有B树，B+树。数据库的索引一般采用这种结构。
- **堆**
  - 大顶堆（最大值永远在堆顶）
  - 小顶堆（最小值永远在堆顶）
- **图**
  - 相对于树来说，图是会形成闭环的，即有指向根节点的子节点。
  - 根据节点之间的连接线有没有方向，分为有向图和无向图。
  - 根据节点之间的线有没有权重，分为加权图和非加权图。
  
### 本周知识小节
本周主要学习了递归算法，包括泛型递归，分治和回溯。因为树本身结构就是通过递归来实现的，所以关于树的题目通常也是递归来解。并且递归可以很好地解决存在重复性的问题。
- **泛型递归**  
  递归也可以理解成是一种循环，它是通过自己调用自己来实现循环的。为了避免无线递归调用，所以在方法体的开始要写好终止条件。  
  一般实现递归的思路就是找**重复性**，将复杂问题分解为简单子问题，然后写递归函数实现子问题的求解过程，并且在求解的前后分别加上终止条件和递归调用。  
  *递归模板如下(感谢超哥的模板)*  
  ```java
  public void recur(int level, int param) { 
      // terminator 
      if (level > MAX_LEVEL) { //满足最小子问题的条件了
        // process result 
        return; 
      }
      // process current logic 
      process(level, param); 
      // drill down 
      recur( level: level + 1, newParam); 
      // restore current status 
     
  }
 
  ``` 
- *参考题目*
  - 括号生成：https://leetcode-cn.com/problems/generate-parentheses/
  - 爬楼梯：https://leetcode-cn.com/problems/climbing-stairs/
- **分治&回溯**  
  - **分治**：分治是指递归调用的时候，不再是单一的重复问题，而是多个子问题的合集。所以就涉及到多个处理分支。
  - **回溯**是指当在某一层递归中发现问题无解了，则返回到上一层重新走另一个分支，回溯算法其实就是自己试错的体现。
- *参考题目*
  - Pow(x, n)：https://leetcode-cn.com/problems/powx-n/
  - 子集：https://leetcode-cn.com/problems/subsets/
  - N 皇后：https://leetcode-cn.com/problems/n-queens/
  
### 总结
对于存在**重复性**问题的题目，判断其最近重复性，如果重复子问题只有一种，则采用泛型递归即可，如果子问题是多个，则采用分治；而如果要在重复问题中寻找最优解的这种问题，一般采用回溯来解决。