# 学习笔记 第二周
## 知识总结
  算法学习的第二周已经结束了，这一周学习了**哈希表，集合，树，堆以及图**这些数据结构的知识。并且针对不同的数据结构，有其不同的使用途径和算法。  
### 哈希表
  - **哈希算法**：任意长度的输入值，返回固定长度的输出值
  - **哈希冲突**：存在不同的输入值，返回的是相同的输出值
  - 哈希表（Hash table），也叫散列表，是根据关键码值(Key，value)而直接进行访问的数据结构。它通过把关键码值通过哈希算法映射到表中一个位置来访问记录，以加快查找的速度。
  - 哈希表的寻址在理想状态下是O(1)的，因为有Hash冲突的存在，最坏的情况下是O(n)的，不过可以通过优化Hash算法和扩大容器容量来避免Hash冲突。
### 哈希表的集合实现
  - **HashMap：**  
  主要的实现就是HashMap，参照后面的HashMap小节。里面介绍了Hash算法和Hash冲突，以及Java1.8中整个HashMap的结构和解决Hash冲突的实现方法。
  - **HashSet：**  
  底层就是通过HashMap来实现，只是利用了Map中Key的位置来保存数据，达到无重复性，故不再赘述。
  - *参考题目：* 
    - 有效的字母异位词：https://leetcode-cn.com/problems/valid-anagram/description/
    - 字母异位词分组：https://leetcode-cn.com/problems/group-anagrams/
    - 两数之和：https://leetcode-cn.com/problems/two-sum/description/	
### 树
  - 为了解决一维的链表寻址慢的问题，作为二维结构的树应运而生，即一个节点不再只有一个next指针，而是由两个或者多个。
  - 相对于一维结构的寻址时间复杂度O(n),树的寻址时间复杂度优化到了O(log(n))。
### 树的实现
  - **二叉树**
  二叉树只有两个节点，左节点和右节点,节点的定义如下：
    ```java
      class TreeNode {
          int val;
          TreeNode left;
          TreeNode right;
          ...
      }
    ```
    二叉树的遍历根据遍历根节点的顺序分为前序遍历（根-左-右），中序遍历（左-根-右），后续遍历（左-右-根）  
  - *参考题目：*  
    - 二叉树的中序遍历：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
    - 二叉树的前序遍历：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/
  - **二叉搜索树**  
  二叉搜索树是一种有序树，并且满足一下特点
    1. 左子树上所有结点的值均小于它的根结点的值； 
    2. 右子树上所有结点的值均大于它的根结点的值； 
    3. 以此类推：左、右子树也分别为二叉查找树。（这就是重复性！）  
  所以二叉所搜树的中序遍历就是升序排列。
### 堆
  - **定义**：可以迅速找到一堆数中的最大值或者最小值的数据结构称之为堆，最大值或最小值放在堆顶，堆顶是最大值的称之为大顶堆，堆顶是最小值的称之为最小堆。
  - **堆的主要实现**：二叉堆和斐波那契堆
    - 二叉堆和二叉搜索树相似，不同点是二叉搜索树的左右节点有大小关系，而堆的左右节点没有要求，只是要求根节点大于/小于子节点。
	- 斐波那契数列是是指当前值等于前两个值得和，即a[i] = a[i-1] + a[i-2]；
  - **堆排序算法**：参照HeapSort.md里面的介绍。
  - *参考题目：*
    - 爬楼梯：https://leetcode-cn.com/problems/climbing-stairs/
	
### 总结
堆和树有着相似的地方，最好不要搞混，就像二叉搜索树和大/小顶堆，都是树状结构。但是区别是有的：  
  1. 二叉搜索树不是完全二叉树；而堆是完全二叉树
  2. 二叉搜索树的左右节点有大小之分；而堆只区分根节点和子节点，两个子节点之间没有要求
  3. 二叉搜索树完全有序；而堆相对有序
  4. 二叉搜索树维护比较麻烦，所以一般用来做查询；堆的维护相对简单，可以用来修改，排序。













